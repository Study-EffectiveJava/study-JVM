
---

# 자바 컴파일 과정

![img1 daumcdn](https://user-images.githubusercontent.com/65555299/218346013-5486fffd-489d-4824-ac5a-437098fe437d.png)
출처: [http://www.tcpschool.com/java/java_intro_programming](http://www.tcpschool.com/java/java_intro_programming)


![Untitled 3](https://user-images.githubusercontent.com/65555299/218346017-3af3f256-ae63-4790-8f61-f8203cc216d8.png)

출처: 처음 해보는 자바 프로그래밍 - 오정임 저

### Java Compiler

- [Java Compiler](https://www.geeksforgeeks.org/compilation-execution-java-program/) : 더 자세한 내용은 해당 링크 보면서 나오는 용어들 찾아가는 식으로
    - 링크 일부분 발췌
        - 어노테이션이 발견된다면 이를 process한다
        - Syntex Tree의 속성을 지정한다. 이 과정에는 name resolution, 타입 체킹, 그리고 지속적인 folding이 포함된다.
    - 위 과정을 포함하여 컴파일이 진행되고, 자바 바이트 코드가 생성된다
- 자바 바이트 코드 : 자바 바이트 코드는 클래스 로더에게 전달된다.

# Class Loader

- 클래스 로더: **런타임 중**에 JVM의 메서드 영역(== 코드 영역)에 동적으로 Java 클래스를 로드하는 역할.
    - 클래스 로더는 실행에 필요한 모든 `실행 파일(*.class)` 을 찾아 준다.

### 클래스 로더가 지켜야 할 세 가지 원칙

- 위임 원칙 : 클래스 로더는 클래스 또는 리소스를 찾기 위해 요청을 받았을 때, 상위 클래스 로더에게 책임을 위임하는 위임 모델을 따른다.
    - 부트스트랩 클래스 로더, 확장 클래스 로더, 시스템(어플리케이션) 클래스 로더
- 가시 범위 원칙 : 하위 클래스 로더는 상위 클래스 로더가 로드한 클래스를 볼 수 있지만, 반대는 안된다.
    - 이로 인해, 상위 클래스 로더에서 로딩하는 java.lang.Object 등의 클래스도 하위 클래스 로더에서 사용할 수 있다.
- 유일성 원칙
    - 하위 클래스 로더가 상위 클래스 로더에게 로드한 클래스를 다시 로드하지 않아야 한다는 원칙이다.


  


## 클래스 로더 동작 방식

![img1 daumcdn](https://user-images.githubusercontent.com/65555299/218346013-5486fffd-489d-4824-ac5a-437098fe437d.png)
출처: [https://blog.hexabrain.net/397](https://blog.hexabrain.net/397)

> 
>
> 1. JVM 의 메서드 영역에 클래스가 로드 되어있는지 확인
>     - 로드되어 있는 경우: 해당 클래스 사용
> 2. 로드되어 있지 않는 경우, `시스템 클래스 로더`에 클래스 로드 요청
> 3. 시스템 클래스 로더는 확장 클래스 로더에 요청을 위임
> 4. 확장 클래스 로더는 부트스트랩 클래스 로더에 요청을 위임
> 5. 부트스트랩 클래스로더는 부트스트랩 Classpath(JDK, JRE, LIB)에 해당 클래스가 있는지 확인, 존재하지 않는 경우 확장 클래스 로더에게 요청 위임
> 6. 확장 클래스 로더는 확장 Classpath(JDK/JRE/LIB/EXT)에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 시스템 클래스 로더에게 요청 위임
> 7. 시스템 애플리케이션 클래스로더는 시스템 Classpath에 해당 클래스가 있는지 확인한다. 클래스가 존재하지 않는 경우 ClassNotFoundException을 발생
> 
> 출처: [https://steady-coding.tistory.com/593](https://steady-coding.tistory.com/593)

### Loading

- 로딩 : 자바 바이트 코드를 메서드 영역에 저장
    - 로드된 클래스를 비롯한 그의 부모 클래스의 정보
    - 클래스 파일과 Class, Interface, Enum의 관련 여부
    - 변수나 메서드 등의 정보
    - 유의할점 : Loading 기능은 한번에 메모리에 올리지 않고, 어플리케이션에서 **`필요한 경우 동적으로 메모리에 적재`**하게 된다

### Linking

- 로드된 파일들을 검증하고, 준비하는 과정이다. 3가지 과정으로 나뉜다.

1. Verification
    - 클래스 파일이 올바른 형식으로 작성 되었는지, 검증된 컴파일러에 의해 생성된 파일인지 여부를 확인하는 과정이다.
    - 검증을 통과하지 못하면, `java.lang.VerifyError` 가 발생한다.
2. Preparation
    - 클래스의 정적 변수를 위한 메모리 공간을 할당하고, 기본 값으로 초기화 하는 과정이다.
    - **메모리가 부족하면 OutOfMemoryError**
    - `static 필드`를 **기본값**으로 초기화하여 메모리에 할당한다
3. Resolution
    - `Symbolic Reference` 을 `Runtime Constant Pool` 의 실제 값으로 동적으로 결정하는 과정이다.
        - `Runtime Constant Pool` 은 JVM 의 `method area` 에 존재 하고, 실제 값은 실제 물리적인 주소(`Direct Reference`)를 의미하는 것이다.
        - `Symbolic Reference` 는 객체의 이름으로 참조하는 것을 의미한다.
    - 객체의 이름에 해당하는 실제 주소를 JVM 의 `Runtime Constant Pool` 이란 곳에서 찾아서 변환해주는 과정
        - 해당 단계의 영향을 받는 JVM Instruction 요소는 `new` 및 `instanceof` 등이 있습니다.

### Initialization

- *Initialization*단계에서는 클래스 파일의 코드를 읽게 된다.
- `Preparation` 과정에서 공간을 확보한 정적 변수 (클래스 및 인터페이스)를 지정한 값으로 초기화하거나 초기화 메서드를 실행하는 과정이다.
  (이때, *JVM*은 멀티 쓰레딩으로 작동을 하며, 같은 시간에 한 번에 초기화를 하는 경우가 있기 때문에 초기화 단계에서도 동시성을 고려해주어야한다)

## 동적 클래스 로딩

클래스 로더는 특정 클래스가 참조되는 시점에 JVM에 링크되고, 메모리에 로드된다. 이를 동적 클래스 로딩이라고 한다.

- 한번에 모든 클래스를 메모리에 올리지 않음으로서 메모리를 효율적으로 사용한다.

즉, JVM은 클래스의 메소드, 필드, 상속관계 등에 대한 정보를 알지 못한다. 따라서, 클래스로더는 클래스를 로딩할 때 필요한 정보를 구하고, 그 클래스가 올바른지를 검사할 수 있어야 한다.

JVM은 내부적으로 클래스를 분석할 수 있는 기능을 갖고 있으며, JDK 1.1부터는 개발자들이 리플렉션(Reflection)을 통해서 이러한 클래스의 분석을 할 수 있도록 하고 있다.

- 로드타임 동적 로딩

    ```java
    public class HelloWorld {
         public static void main(String[] args) {
            System.out.println("안녕하세요!");
         }
    }
    ```

    1. 모든 클래스의 부모 클래스인 Object가 로딩된다.
    2. HelloWorld를 로딩하기 위해 HelloWorld.class를 읽는다.
    3. HelloWorld를 로딩하는데 필요한 클래스들을 찾는다.
    4. java.lang.String과 java.lang.System 이 두 클래스가 필요한데, 이 두 클래스는 HelloWorld가 로드되는 시점에서 로딩된다. 이렇게 하나의 클래스를 로딩하는 과정에서 동적으로 클래스를 로딩하는 것을 로드타임 동적 로딩이라고 한다.

- 런타임 동적 로딩

    ```java
    public class RuntimeLoading {
       public static void main(String[] args) {
          try {
             Class klass = Class.forName(args[0]);
             Object obj = klass.newInstance();
             Runnable r = (Runnable) obj;
             r.run();
          } catch(Exception ex) {
             ex.printStackTrace();
          }
       }
    }
    ```

    1. RuntimeLoading이 로딩되고, 실행에 필요한 모든 클래스들이 이미 로딩되어 있다.
    2. Class.forName(args[0]) 코드가 실행되기 전까진 어떤 클래스를 참조하는지 알 수 없다.
    3. 위 코드가 실행되는 순간에 args[0]에 해당하는 클래스명을 찾아와 클래스를 로딩한다. 이러첨 클래스를 로딩할 때가 아닌 코드를 실행하는 순간에 클래스를 로딩하는 것을 런타임 동적 로딩이라고 한다.

# JIT 컴파일러

### 바이트 코드

바이트 코드는 자바 가상 기계에서만 실행되는 기계어로 운영체제와 CPU에 관계 없는 바이너리 코드를 말한다.

자바 컴파일러는 자바 소스 프로그램을 컴파일 하여 바이트코드로 된 클래스 파일(.class)을 생성한다. 이 클래스 파일은 운영체제에 의해 실행되는 것이 아닌 JVM의 인터프리터 방식으로 실행된다.

### 인터프리터 방식의 성능 이슈

코드를 기계어로 변환하는 방식은 두가지가 있다.

<aside>
👉🏻 - **컴파일러 방식**: 소스 코드를 한번에 기계어로 변환
- **인터프리터 방식**: 빌드 시점이 아닌 런타임에 한 줄씩 읽으면서 기계어로 변환

</aside>

자바의 JVM은 인터프리터 방식을 사용하여 한줄씩 읽어 기계어로 변환하였는데, 이것 때문에 자바에서 속도가 느리다는 이슈가 많았다.

>
>
>
> ### 왜 인터프리터가 컴파일에 비해 속도가 느린가?
>
> 간단한 예로는 하나의 루프에서 작업된 코드가 있다면 컴파일러는 한번에 번역하는 반면 인터프리터는 루프 내의 코드를 반복될 때마다 다시 번역하기 때문이다.
>
> 그리고 컴파일러는 바이너리 코드의 순서를 파악하여 실행이 빠른 순서로 명령어의 순서를 변경하여 실행되도록 하는 역할을 할 수 있지만, 인터프리터는 한줄 한줄 읽기 때문에 이런 능력이 없다.
>
> 따라서, 인터프리터가 컴파일러보다 느릴 수 밖에 없다.
>

## JIT 컴파일러

---

<aside>
💡 JIT 컴파일러는 이름은 컴파일러지만 실행 시점에 JVM 내에서 실행된다.

</aside>

JVM은 어디서든 실행이 가능한 환경을 구성해주면서, JIT 컴파일러와 상호작용 하며 인터프리터로 최적화된 바이트 코드를 실행시키면서 바이너리로 컴파일 할 수 있게 된다.

### 핫스팟 컴파일

일반적으로 프로그램은 전체 코드 중 **일부**만 자주 실행되고, 애플리케이션의 성능은 이 **일부**가 얼마나 빠르게 실행되는 가에 좌우된다.

바로 자주 실행되는 일부를 애플리케이션의 중요 영역이라하여 `핫스팟`이라고 부른다. 이 영역의 코드가 많이 실행될 수록 핫해진다고 표현한다.

JVM은 핫스팟을 고려하여 바로 코드를 컴파일하지 않는다. 두 가지의 이유로 설명할 수 있다.

- 코드가 한 번만 실행된다면 컴파일이 헛수고다. 미리 컴파일을 하는 것보다 자바 바이트 코드를 인터프리트 하는 편이 빠를 것이다. → 단 한번만 실행되는 코드이므로.
    - 자주 호출되는 메소드이거나 루프일 경우 당연히 미리 컴파일을 하는 것이 이득이다.
- 최적화 문제와 관련이 있다. JVM이 특정 메소드 또는 루프를 실행하는 시간이 길어질 수록 코드에 대해 얻어지는 정보가 많다. 따라서, JVM이 코드를 컴파일할 때에 최적화를 많이 적용하게 된다.
    - 오버라이드 된 메소드의 대상이 무엇인지 찾기 위해서는 인터프리터에서 할 경우 시간이 오래 걸리게 된다. (equals 메소드 오버라이드가 대표적인 예시)
    - 하지만 컴파일 시에 타입을 추론해두고, 대상이 무엇인지 파악한 후에 미리 찾아놓는다면 최적화된 코드를 만들어놓을 수가 있다.
    - `for문에 대한 최적화에도 차이가 난다`
        - interpreter는 매번 for loop 내부의 코드를 기계어로 반복해서 번역
        - compiler는 미리 번역된 기계어를 반복 사용

JIT 컴파일러는 앞서 말한 핫스팟과 같은 영역의 코드를 미리 컴파일하여 다시 사용할 때에 캐시에 담아두었다가 바로 꺼내서 실행하는 역할을 수행한다.

미리 컴파일하는 방식의 컴파일 방식을 사용하기 때문에 단 한번만 컴파일이 수행되며, 변환된 기계어는 캐시에 저장된다.

JVM은 코드들의 수행 빈도와 복잡도에 따라 총 4가지 레벨로 분류하여 코드를 수행하는데, 이중 1~3레벨 코드는 C1 컴파일러를 이용해 기계어로 컴파일만 수행하고 캐싱은 수행하지 않으며, 4레벨 코드는 C2 컴파일러를 이용해 기계어로 컴파일 뿐 아니라 기계어 캐싱까지 수행한다.

### 정리

JIT 컴파일러는 인터프리터로 코드를 한줄 한줄 실행하기 전에 한번 스캔하여 반복되는 구문을 확인한다. 그리고 인터프리터 방식으로 코드를 실행하다가 이전에 판단한 중복 구문을 만나면 캐시에 변환한 기계어를 담아둔다. 그리고 다시 인터프리터가 그 부분을 실행할 때에는 담아둔 기계어를 바로 반환하게 된다.

- JIT 컴파일러는 바이트코드를 nativecode(기계어)로 바꾸기 때문에 실행이 빠르지만 nativecode(기계어)로 변환하는데 비용(프로세서 시간과 메모리 사용량)이 발생한다.
- 이런 `변환 비용` 때문에 jvm은 모든 코드를 JIT Compiler방식으로 실행하지 않고 `인터프리터 방식`을 사용하다 자주 사용되는 코드만 캐싱한다.
- JVM은 내부적으로 어떤 메서드가 얼마나 자주 수행되는지를 확인하고 HotSpot이라고 판단하면 컴파일을 수행해놓는다.

### Bytecode Verifier

- 바이트 코드가 로딩된 후 명령어가 장애를 일으키는지 검사하는 과정이다.
- 다음 항목들을 검사한다.
    - 변수가 사용되기 전에 `초기화`되는지
    - 객체 참조의 `타입`이 메서드 호출과 일치하는지
    - `private` 데이터와 메서드에 대한 잘못된 `접근`이 있는지
    - `로컬 변수`에 대한 접근이 런타임 메모리의 `스택`에서 이루어지고 있는지 (블록 밖에서 로컬 변수 참조X)
    - 런타임 메모리의 스택이 `오버플로우`가 발생하지 않는지

  → 이 항목 중 하나라도 `실패`하면 통과시키지 않는다.


# 생각해볼만한 내용

## static은 정적? 동적?

---

static이 언제 적재되는 지 알아보면 정답이 나온다. static은 **컴파일 시에 메모리에 올라가게 된다**. 그렇기 때문에, 객체가 생성되는 것과 관계가 없으며, (public일 경우) 모든 인스턴스가 자유롭게 접근이 가능하다.

따라서, static은 컴파일 시에 메모리에 올라가야 하기 때문에 컴파일 시에 값이 할당되어야 하며, 정적 바인딩에 해당된다.

<aside>

> 🚨 정적 팩토리 메서드는 오버라이딩이 불가능하다 ?!
> 
> 우리는 다형성을 통해 다양한 메소드를 오버라이딩 할 수 있다. 그렇다면 static 메소드도 오버라이딩이 될까?
> 
> 우선 오버라이딩이 언제 바인딩이 되는지 알아보자.
> 오버라이딩은 Runtime 시점에 사용될 메소드가 결정된다. 왜냐하면 컴파일러는 다형성을 판단할 때 구체적인 인스턴스의 타입을 파악하지 않기 때문이다. 예를 들어
> 
> ```java
> Person person = new Student("학생1", 15); // symbolic reference
> 
> person.getName();
> ```
> 
> 위와 같이 다형성을 활용한 경우가 있다고 해보자.
> 
> 컴파일러는 위의 코드를 바이트코드로 변경할 때, person에 객체가 할당되지 않는다. 왜냐하면 객체를 생성하는 것은 Runtime시에 일어나기 때문에, person이라는 변수에 어떤 타입이 들어올지 컴파일러는 알수가 없다.
> 
> 따라서 person이 부르는 getName이라는 메소드가 어떤 클래스에 속해 있는지 결정할 수 없기 때문에 오버라이딩의 경우 Runtime에 변수의 값, 메소드의 주소 연결이 할당되는 동적 바인딩일 수 밖에 없다.
> 
> 하지만 정적 메소드의 경우 객체의 형성과 관계 없이 컴파일 시에 메모리에 적재된다. 따라서 컴파일러가 정적 메소드를 부르고 있는 실제 객체를 찾지 않고, 바로 메소드를 찾아버린다. 그러면 그 메소드는 메모리에 적재된 정적 메소드에 연결된다.
> 
> 따라서, 정적메소드를 오버라이딩 한다는 개념은 아에 성립할 수 없다. IDE에서 작성하게 되면 정적 메소드에 `@Override`를 붙일 경우 컴파일 에러가 발생하는 것을 발견할 수 있다.
> 
> </aside>

> **class 파일은 JVM위에서 Linking 작업을 수행할 수 있도록, 라이브러리에 대한 Symbolic Reference만을 가지고 있게 됩니다.**
>

그리고 클래스나 클래스 내의 static 멤버들을 소스를 실행하자마자 한번에 메모리에 모두 올라가는줄 착각하는데, 언제 어디서 사용될지 모르는 static 멤버들을 처음에 전부 메모리에 올린다는건 비효율적이기 때문에,  클래스 내의 멤버를 호출하게 되면 그때서야 클래스가 동적으로 메모리에 로드된다.

즉, JVM은 실행될때 모든 클래스를 메모리에 올려놓지 않고, 그때 마다 필요한 클래스를 메모리에 올려 효율적으로 관리하는 것이다.

# 참고

### 클래스 로더

[[Java] JVM의 클래스 로더란?](https://steady-coding.tistory.com/593)

[Compilation and Execution of a Java Program - GeeksforGeeks](https://www.geeksforgeeks.org/compilation-execution-java-program/)

[How JVM Works - JVM Architecture? - GeeksforGeeks](https://www.geeksforgeeks.org/jvm-works-jvm-architecture/?ref=lbp)

[클래스 로더(Class Loader)](https://goodgid.github.io/Java-Class-Loader/)

[클래스로더 1, 동적인 클래스 로딩과 클래스로더](https://javacan.tistory.com/entry/1)

[](https://www.baeldung.com/java-classloaders)

[Chapter 5. Loading, Linking, and Initializing](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.4.3)

[https://tecoble.techcourse.co.kr/post/2021-07-15-jvm-classloader/](https://tecoble.techcourse.co.kr/post/2021-07-15-jvm-classloader/)

### JIT 컴파일러

[자바 JIT 컴파일러](https://velog.io/@youngerjesus/자바-JIT-컴파일러)

[JVM의 JIT(Just In Time Compilation) 컴파일이란? C1, C2 컴파일러를 이용한 최적화](https://kotlinworld.com/307)
